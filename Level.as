package  {		//imports	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.text.TextField;		public class Level extends Sprite {				//setting up some constants		static const SPACING:int = 25;		static const ROWS:int = 16;		static const COLS:int = 19;		static const MOVESTEP:int = 5;		static const YOFF:int = 25;		static const XOFF:int = 25;				//pseudo constant - the value needs to be given by the constructor		static var NEED:int;				//some level variables		private var _gameSprite:Sprite;		private var _blocks:Array;		private var _checkCols:Boolean;		private var _score:int;		private var _bonus:int;		private var _score_tf:TextField;		private var _needed:int;		private var _needed_tf:TextField;		private var _numLevel:int;		public function Level(numLevel:int, blocksNeeded:int, score:int = 0) {			this.addEventListener(Event.REMOVED_FROM_STAGE, destroy);						_numLevel = numLevel;			_needed = blocksNeeded;			NEED = blocksNeeded;			_score += score;						startGame();			setupHUD();					}				private function destroy(e:Event):void {			removeChild(_gameSprite);			removeChild(_score_tf);			_score_tf = null;			removeChild(_needed_tf);			_needed_tf = null;			this.removeEventListener(Event.REMOVED_FROM_STAGE, destroy);		}				private function setupHUD():void {			//creating the 'Score:' textfield			var scoresTf:TextField = Static.textField('Score:');			scoresTf.y = 440;			scoresTf.x = 20;			addChild(scoresTf);						//creating the score textfield			_score_tf = Static.textField(_score.toString());			_score_tf.y = 440;			_score_tf.x = 90;			addChild(_score_tf);						//creating the 'Blocks needed:' textfield			var blocksTf:TextField = Static.textField('Blocks needed:');			blocksTf.y = 440;			blocksTf.x = 160;			addChild(blocksTf);						//creating the blocks needed textfield			_needed_tf = Static.textField(_needed.toString());			_needed_tf.y = 440;			_needed_tf.x = 325;			addChild(_needed_tf);						//creating the 'Level:' textfield			var levelTf:TextField = Static.textField('Level:');			levelTf.y = 440;			levelTf.x = 390;			addChild(levelTf);						//creating the level textfield			var level_tf:TextField = Static.textField(_numLevel.toString());			level_tf.y = 440;			level_tf.x = 455;			addChild(level_tf);		}				//start the game		private function startGame():void {			//create the blocks array			_blocks = new Array();						//creeate the arrays inside the blocks array			for(var cols:int; cols < COLS; cols++) {				_blocks.push(new Array());				}						//create the sprite to hold the game			_gameSprite = new Sprite();						_gameSprite.addChild(Static.bitmap(new Levelbg(50, 50)));						//add the blocks to the game sprite			for(var c:int = 0; c < COLS; c++) {				for(var r:int = 0; r < ROWS; r++) {					addBlock(c, r);					}			}						//add the gamesprite to the stage			addChild(_gameSprite);						//set the checkCols variable to false because we're not checking any columns yet			_checkCols = false;						//add an event listener to be able to move the blocks			addEventListener(Event.ENTER_FRAME, moveBlocks);		}//end startGame()				private function moveBlocks(e:Event):void {			//if the block has been moved			var moved:Boolean = false;						//loop through all the rows and columns			for(var r:int = 0; r < ROWS; r++) {				for(var c:int = 0; c < COLS; c++) {					var block:Block = _blocks[c][r];					//if the block hasn't been removed					if(block != null) {						//check if it needs to move down						if(block.y < block.row * SPACING + YOFF) {							block.y += MOVESTEP;							moved = true;							}						//check if if needs to move left						else if(block.x > block.col * SPACING + XOFF) {							block.x -= MOVESTEP;							moved = true;						}					}					}			}						//if all the blocks are in the right place we need to check if there are any empty columns			if(!moved && _checkCols) {				_checkCols = false;				checkEmptyColumns();				}						}//end moveBlocks()				//add the blocks to the game sprite		private function addBlock(col:int, row:int):void {			//get a random number between 1 and 4			var type:int = Math.ceil(Math.random() * 4);									var block:Block = new Block();			block.row = row;			block.col = col;			block.type = type;			block.setType(type);						//put the block in the right position based on the spacing, X and Y offset and the column and row			block.x = col * SPACING + XOFF;			block.y = row * SPACING + YOFF;						//add the block to the stage			_gameSprite.addChild(block);						//add the block to the array of blocks			_blocks[col][row] = block;						//add a click listener			block.addEventListener(MouseEvent.CLICK, clickBlock);			}//end addBlock()				private function clickBlock(e:MouseEvent):void {			//save the current block into a variable			var block:Block = Block(e.currentTarget);						//get the number of points from the matchmaking function			var points:int = findAndRemoveMatches(block);						//if there are any points we need to add them to the _score variable			if(points > 0) {				_score += points;				_score_tf.text = _score.toString();				if(points >= 500) {					Static.playLonger();				} else {					Static.playSound();				}			}		}//end clickBlock()				//find the matches of the given block and remove them		private function findAndRemoveMatches(block):int {			//save the type into a variable because the type will be changed and might need to be resored			var type:int = block.type;						//an array of blocks that match the passed in block			var matches:Array = testBlock(block.col, block.row, type);						//if there are enough matches we need to remove them			if(matches.length > 1) {				//remove all of them and make the rest drop				for(var i:int = 0; i < matches.length; i++) {					_gameSprite.removeChild(matches[i]);					moveAbove(matches[i]);					_needed_tf.text = _needed--.toString();				}								//set the checkCols variable to true to check for empty columns				_checkCols = true;								//return the score based on the number of blocks				if(matches.length < 10) {					return matches.length * matches.length;					} else if(matches.length > 10) {					return (matches.length * matches.length) * 2;					}			}			//if there weren't enough matches			else {				block.type = type;			}						//no points scored			return 0;		}//end findAndRemoveMatches()				//move all the blocks above a removed block		private function moveAbove(block):void {			//remove the current block from the array			_blocks[block.col][block.row] = null;						//save the column into a variable			var c:int = block.col;						//loop through the rows above			for(var r:int = block.row - 1; r >= 0; r--) {				//if the block is there				if(_blocks[c][r] != null) {					_blocks[c][r].row++;					_blocks[c][r+1] = _blocks[c][r];					_blocks[c][r] = null;					}			}		}//end moveAbove()				//test the block specified to see if it has matches		private function testBlock(col:int, row:int, type:int):Array {			//the array of matches to return			var matches:Array = new Array();						//if the block doesn't exits we return an empty list			if(getType(col, row) == 0) return matches;						//if the block is of the right type			if(_blocks[col][row].type == type) {				//add the block to the matches				matches.push(_blocks[col][row]);				//make it's type 0				_blocks[col][row].type = 0;								//recursively test in all directions				//one to the right				matches = matches.concat(testBlock(col+1, row, type));				//one to the left				matches = matches.concat(testBlock(col-1, row, type));				//one up				matches = matches.concat(testBlock(col, row+1, type));				//one down				matches = matches.concat(testBlock(col, row-1, type));			}						//return the restuls			return matches;		}//end testBlock()				//get the type of the block in the col and row given		private function getType(col:int, row:int):int {			//check to see if the location is valid			if(col < 0 || col >= COLS) return 0;			if(row < 0 || row >= ROWS) return 0;						//check that the block exists			if(_blocks[col][row] == null) return 0;						//if the block exists everything is fine			return _blocks[col][row].type;			}//end getType()				private function checkEmptyColumns():void {			// assume no column found			var foundEmpty:Boolean = false;			var blocksToMove:int = 0;							// loop through each column, left to right			for(var col:int=0;col<COLS;col++) {								// if no empty found yet				if (!foundEmpty) {										// see if bottom block is gone					if (_blocks[col][ROWS-1] == null) {												// this column is empty!						foundEmpty = true;												// remember to check for empty columns again						_checkCols = true;					}									// empty column found before, so this one must move over				} else {										// loop through blocks and set each to move left				for(var row:int=0;row<ROWS;row++) {						if (_blocks[col][row] != null) {							_blocks[col][row].col--;							_blocks[col-1][row] = _blocks[col][row];							_blocks[col][row] = null;							blocksToMove++;						}					}				}			}						// didn't move any blocks, check to see if the game is over			if (blocksToMove == 0) {				_checkCols = false;				checkForLevelOver();			}		}				//check to see if the level is over		private function checkForLevelOver() {			//loop through all the blocks that are left			for(var c:int = 0; c < COLS; c++) {				for(var r:int = 0; r < ROWS; r++) {					//if the block matches up or to the right there are move possible					var block:int = getType(c, r);					if(block == 0) continue;					if(block == getType(c+1, r)) return;					if(block == getType(c, r+1)) return;					}			}						//if no possible moves were found the level must be over			endLevel();		}				private function endLevel():void {			_needed_tf.text = _needed.toString();			var left:uint;			for(var c:int = 0; c < COLS; c++) {				for(var r:int = 0; r < ROWS; r++) {					var block:int = getType(c, r);					if(block != 0) left += 1;				}			}			if(_needed <= 0 && _numLevel != 6) {				var more:int = (_needed * -1);				if(more < 0) more *= -1;				_bonus = more * 10;				if(left <= 0) _bonus += 10000;				dispatchEvent(new Event('levelComplete'));			} else {				dispatchEvent(new Event('gameOver'));			}					}				public function get score():int {			return _score;		}				public function get bonus():int {			return _bonus;		}	}	}